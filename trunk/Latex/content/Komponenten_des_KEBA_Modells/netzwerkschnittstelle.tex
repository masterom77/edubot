\subsection{Netzwerkschnittstelle}
\subsubsection{Allgemein}
Die Netzwerkschnittstelle des KEBA Modells ist auf der SPS implementiert und soll die Kommunikation mit der Roboter API ermöglichen, diese Kommunikation verläuft über Sockets und unterscheidet sich im Prinzip wenig von jener auf dem Edubot Modell, lediglich die Art der Implementierung unterscheidet sich auf Grund der unterschiedlichen Programmierumgebungen sehr stark. Für die implentierung der Netzwerkfunktionalität wurde die frei zur Verfügung stehende OSCAT Library verwendet, welche im Kapitel "'Verwendete Technologien und Werkzeuge"' kurz erklärt wird. 

Die Netzwerkschnittstelle ist sowohl für den Empang von Befehlen und Pfaden, als auch für die Rückgabe von Statusinformationen verantwortlich und ist auf der SPS als Aufgabe ohne harte Echtzeitanforderungen definiert, da keine Hardware direkt angesteuert wird und es dadurch nicht nötig ist zu einem genau bestimmten Zeitpunkt zu arbeiten.

\subsubsection{Aufbau}
Die Netzwerkschnittstelle ist im Programm \textit{NetworkManager} implementiert und wird durch einen Entsprechenden "'Task"' in zyklischen Abständen von 200ms aufgerufen. Da nicht bei jedem Programmaufruf sämtliche Operationen wie beispielsweise die Initialisierung der für den Empfang benötigten Variablen vorgenommen werden sollen, sondern vielmehr abhängig vom aktuellen Status der Kommunikation unterschiedliche Programmteile benötigt werden, basieren zyklisch aufgerufenen Programmen meist auf einer \textit{Switch} Kontrollstruktur. Die \textit{Switch} Kontrollstruktor entscheidet mittels einer \textit{status} Variable, welche Operationen derzeit benötigt werden. In den einzelnen Fällen der \textit{Switch} Struktur befindet sich die Programmlogik die Ausgeführt werden soll wenn die \textit{status} Variable den Wert dieses Falles annimmt. Üblicherweise ist der ist der Anfangswert der \textit{status} Variable 0, wodurch beim ersten zyklischen Aufruf des Programms die dem Fall 0 zugeordnete Programmlogik ausgeführt wird. Diese Programmlogik kann beispielsweise zur Initialisierung von Variablen dienen. Wurde die Inititialisiierung, um kurz an diesem Beispiel festzuhalten, erfolgreich beendet, so wird im Fall 0 noch die \textit{status} Variable so gesetzt, dass beim nächsten Programmaufruf die nach der initialisierung auszuführende Programmlogik ausgeführt wird. Dieses Prinzip kann nun innerhalb des Programms beliebig fortgeführt werden.

\subsubsection{Umsetzung}
Auf die genau Implementierung der Netzwerkkommunikation auf der SPS wird hier nur oberflächlich eingegangen, genauere Informationen hierzu sind der Dokumentation der OSCAT Network Library und dem Source Code der SPS zu entnehmen, welcher im Rahmen der Diplomarbeit gemeinsam mit der restlichen Software des Edubot Systems abgegeben wurde. Im Folgenden erfolgt lediglich eine Kurze Aufzählung der wichtigsten Objekte und ihrer Verwendung:
\begin{itemize}
\item \textbf{IP\_CONTROL}\\
Der Typ IP\_CONTROL ist der zentrale Baustein einer Netzwerkkommunikation mit OSCAT. Über ein Objekt dieses Typs werden alle wichtigen Operationen zur Komunikation, wie beispielsweise das anlegen eines Sockets und das Empfangen der Daten abgewickelt. Zum Verbindungsaufbau über ein IP\_CONTROL Objekt ist es lediglich Nötig, dieses mit den entsprechenden Parametern anzulegen und in periodischen Abständen zu Überprüfen ob bereits eine Verbindung hergestellt wurde, dies geschieht über das state Attribut des IP\_CONTROL Objekts, welches jederzeit den Verbindungsstatus in Form eines Integer Wertes beinhaltet, die möglichen Werte dieses Attributs sind der OSCAT Network Library Dokumentation zu entnehmen

\item \textbf{IP\_C}\\
Zur Erzeugung eines IP\_CONTROL Objekts muss ein IP\_C Objekt übergeben werden, welches alle nötigen Parameter für die Verbindung enthält. Zwar verfügt das IP\_CONTROL selbst bereits über einige entsprechende Attribute, diese sollten jedoch nur als default Werte verwendet und von denen im IP\_C Objekt überschrieben werden. 
Wichtige Attribute eines IP\_C Objekts sind zum Beispiel C\_MODE, welches angibt welche Art der Verbindung aufgebaut werden soll, C\_ENABLE zum freigeben der Verbindung und R\_OBSERVE zur Aktivierung des Dateiempfangs.

\item \textbf{NETWORK\_BUFFER}\\
Bei der Erzeugung eines IP\_CONTROL Objekts muss um das Senden beziehungsweise Empfangen von Nachrichten zu ermöglichen je ein Objekt vom Typ NETWORK\_BUFFER als Lesebuffer und eines als Schreibbuffer mitgegeben werden. Ein Objekt vom Typ NETWORK\_BUFFER ist grundsätzlich dazu da entweder empfangene Daten zu einem Stream zu Sammeln um sie später komfortabel auslesen zu können oder zu sendende Daten für die Netzwerkübertragung aufzubereiten um sie später als den zulässigen Blockgrößen entsprechende Pakete zu versenden.
\end{itemize}

\subsubsection{Ablauf des Datenempfanngs}

Um eine Netzwerkverbindung herzustellen muss zuerst ein IP\_C Objekt zur Speicherung der Verbindungsparameter (siehe Kapitel "'Umsetzung"') angelegt werden.
Ebenfalls vor Beginn der Kommunikation müssen zwei NETWORK\_BUFFER Objekte für das Senden und Empfangen von Daten angelegt und initialisiert werden. 
Wie bereits im Kapitel "'Aufbau"' beschrieben, basiert die Netzwerkkomunikation auf einem zyklisch aufgerufenen Programm, welches über einen \textit{Integer} Variable die aktuell auszuführende Operation definiert. Die eben beschriebenen Operationen sollen am Anfang des Programms und somit wenn die \textit {state} Variable auf ihren Initialwert 0 gesetzt ist ausgeführt werden. Nach der Ausführung dieser Schritte wird \textit {state} so gesetzt dass beim nächsten Programmaufruf der nächste Schritt ausgführt wird, in unserem Fall wird \textit{state} auf 10 gesetzt.

Als nächster Schritt (\textit{state} = 10) muss nun ein  IP\_CONTROL aufgerufen werden. Die vorher instanzierten Objekte hierbei werden direkt übergeben. Durch diesen Schritt beginnt die SPS auf eingehende Verbindungen zu horchen.
Ein Beispiel für den Aufruf des IP\_CONTROL's sieht folgendermaßen aus:

IP\_CONTROL1(PORT:=400 ,TIME\_OUT:=T\#1s,IP\_C:= IP\_C1,S\_BUF:=S\_BUF1, R\_BUF:=R\_BUF1 );

Durch regelmäßiges überprüfen des \textit{state} Attributs des IP\_CONTROL Objektes kann nun festgestellt werden wenn eine neue Verbindung hergestellt wurde. Bekommt das \textit{state} Attribut des IP\_CONTROLs den Wert 254, so wurde die Verbindung erfolgreich aufgebaut und es kann zum Datenempfang übergegangen werden. Hierzu wird die \textit{state} Variable des Programms auf 30 gesetzt.

Während des Wartens auf Dateiempfang (\textit{state} = 30) wird in regelmäßigen Abständen das \textit{size} Attribut des dem IP\_CONTROLL mitgegebenen NETWORK\_BUFFER Objekts - im obigen Beispielfall R\_BUF1 - überprüft. Nimmt das \textit{size} Attribut einen Wert an der höher als 0 ist, so wurden Daten empfangen und können aus dem NETWORK\_BUFFER ausgelesen werden. Der NETWORK\_BUFFER enthält hierzu ein array aus \textit{byte} Werten welches werden kann. Die einzelnen Byte Werte werden mithilfe einer einfachen selbst geschriebenen Funktion (siehe BYTE\_TO\_CHAR Funktion im Kapitel "'Hilfsfunktionen"') in eine Zeichenkette umgewandelt. Die \textit{state} Variable wird dannach auf den Wert 40 gesetzt um im nächsten Programmdurchlauf die empfangene Zeichenkette zu analysieren.

Liegt die übertragene Nachricht als Zeichenkette vom Typ \textit{string} vor (\textit{state = 40}), so werden zuerst ihre ersten drei Buchstaben überprüft. Diese drei Buchchstaben enthalten, ähnlich wie beim Edubot Modell, die Information welche Operation ausgeführt werden soll. 
Abhängig von der zu tätigenden Operation werden nun globale Variablen verändert, Daten konvertiert. Die folgende Auflistung gibt an welche Aktionen bei Empfang der wichtigsten Befehle ausgeführt werden:

\begin{itemize}
\item \textbf{Befehl "mvs"}\\
Der Befehl informiert die Steuerung darüber, dass eine lineare Bewegung ausgeführt werden soll. Enthält die Empfangene Zeichenkette diesen Befehl in ihren ersten drei Zeichen, so enthält der rest der Zeichenkette alle zum Abfahren dieser Bewegung benötigten Punkte.
Mit Hilfe einer weiteren selbst geschriebenen Funktion (siehe "'InterpretToGlobalStepArray"' Funktion im nächsten Kapitel "'Hilfsfunktionen"') wirden die in der Zeicehnkette enthaltenen Interpolationspunkte in Arrays vom Typ Real (Gleitkommadatentyp) umgewandelt und als globale Variablen abgelegt. Hierbei wird für jede Achse ein Array angelegt das für jeden Intapolationsschritt den richtigen Winkel angiebt. Aus diesem Array liest später der für die Bewegung zuständige "'MotionTask"' die aktuell zu verfahrenden Winkel aus und übergiebt sie an die Motorsteuerung um die Bewegung phsysisch durchzuführen. Dieser Vorgang ist im Unterkapitel "'Steuerung der Motoren"'' genauer erklärt. Zusätz
\item \textbf{Befehl "hom"}\\
Enthält die empfangene Zeichenkette als Präfix die Zeichen "hom", so wird der Steuerung bekannt gegeben dass der Roboter seine Ausgangsposition suchen soll. Da zum aktuellen Zeitpunkt keine Hardware zur Verfügung stand konnte dieser Vorgang nicht implementiert werden und es wird hier lediglich ein globaler \textit{boolean} Wert auf \textit{true} gesetzt welche später "'MotionTask"' den "'Homing Prozess" auslösen soll.'
\item \textbf{Befehl "sht"}\\
Der Befehl "sht" dient dazu den Roboter auszuschalten, also alle Motoren zu deaktivieren und sonstige zum herunterfahren nötige Abläufe durchzuführen. 
\end{itemize}

\subsubsection{Hilfsfunktionen}
Um diverse Umrechnungen zu vereinfachen und redundaten Programmcode zu vermeiden wurden diverse Hilfsunktionen erzeugt die an enprechnder Stelle im\textit{ NetworkManager} Programm verwendet werden, die folgende Auflistung soll einen Überblick über diese Funktionen bieten, Informationen über ihre Funktionalität bereitstellen und ihre Verwendung im Programm kurz beschreiben:

\begin{itemize}
\item \textbf{BYTE\_TO\_CHAR}\\
Da von CoDeSys standardmäßig keine Funktion zur umrechnung eines \textit{byte} Wertes in einen \textit{char} Wert zur Verfügung gestellt wird, diese aber für die Umrechnung des empfangenen \textit{byte} Arrays in einen String benötigt wird, musste eine entsprechende Funktion selbst erzeugt werden. Die beschriebene Funktion erhält als input Parameter einen einzelnen \textit{byte} Wert und gibt einen Einstelligen \textit{string} Wert zurück, welcher als Inhalt den umgerrechneten \textit{byte} Wert enthält. Das \textit{NetwokManager} Programm ruft diese Funktion innerhalb einer Schleife auf welcher das empfangene \textit{byte} Array mit Hilfe einer Schleife durchläuft und die Ergebnisse der Umrechnung zu einem einzigen String zusammenfügt.

\item \textbf{CHAR\_TO\_BYTE}\\
Diese Funktion bildet das Gegenstückk zur im letzten Schritt beschriebenen Methode, sie wandelt einzelne \textit{char} Werte in Bytes um. Dies ist notwendig um im \textit{NetwokManager} Programm den an den Computer zu sendenden, als \textit{string} vorliegeneden Status  in ein sendbares \textit{byte} Array umzuwandeln, auch hier kommt wieder eine Schleife zur einzelnen Umwandlung aller im \textit{string} enthaltenen Zeichen zum Einsatz.

\item \textbf{InterpretToGlobalStepArray}\\
Da die Empfangenen Schrittinformation in Form einer Zeichenkette nicht direkt vom "'Motion Task" verwendet werden kann, ist es notwendig diese vorher in einzelne Arrays für jeden Motor zu zerlegen. Hierzu wird der Funktion \textit{InterpretToGlobalStepArray} die zu konvertierende Zeichenkette übergeben. In der Funktion selbst wird die Zeichenkette wiederum in einzelne Zeichenketten zerlegt die jeweils die zu verfahrenden Winkel für einen einzelnen Schritt pro Motor angeben. Diese Zeichenkette wird zur Umwandlung der Winkelstellungen in Werte vom Typ \textit{real} der Hilfsfunktion \textit{InterpretToAngles} überbeben. Das von der genannten Funktion zurückgegebene Array enthält nun gewünschten Winkel in Werten vom Typ \textit{real}. Diese Werte werden nun in die globalen Array der einzelnen Motoren angefügt. Nach Umwandlung aller Werte wird schließlich die globale Variable \textit{stepsAvailable} auf die Anzahl der konvertierten Schritte gesetzt. Zusätzlich wird die globale Variable \textit{robot\_ready} auf \textit{false} gesetzt.

\item \textbf{InterpretToAngles}\\
Diese Funktion dienst dazu, die in Form einer Zeichenkette als Parameter übergebenen Winkel eines einzelnen Interpolationsschrittes in ein Array vom Typ \textit{real} umzuwandeln und zurückzugeben.

\end{itemize}

\subsubsection{Der Rückmelde-Prozess}
Wurden der Datenempfang und alle im \textit{NetworkManager} durchzuführenden Operation zur ordnungsgemäßen Abarbeitung der Befehle abgeschlossen, so wird wie im Kapitel "'Ablauf des Dateiempfang"' bereits erwähnt, die \textit{state} Variable des Programms auf 110 gesetzt. Befindet sich das Programm in diesem Zustand, so werden bei jedem Aufruf globale Statusvariablen überprüft um bei bestimmten Veränderungen eine entsprechende Rückmmeldung an den Verbundenen Computer zu geben. Die wichtigsten Variablen sind hierbei \textit{robot\_ready}, \textit{robot\_shutdown} und \textit{robot\_failure}.

Ist die \textit{robot\_ready} Variable auf \textit{true} gesetzt, so sendet das \textit{NetworkManager} wird zuerst eine Zeichenkette mit dem Wert "'ready"' erzeugt, mithilfe einer Schleife und der der Hilfsfunktion CHAR\_TO\_BYTE in einzelne Bytes zerlegt und dem zum Senden vorgesehenen NETWORK\_BUFFER Objekt übergeben. In unserem Fall trägt dieses Objekt den Namen "'S\_BUFF1"'. Nun kann durch Aufruf des IP\_CONTROLLs die Zeichenkette an den Computer übergeben werden um zu signalisieren dass der Roboter bereit ist neue Befehle zum empfangen. Nach Beendigung der Übertragung wird die \textit{state} Variable des Programms auf den Wert 30 gesetzt um beim nächsten Aufruf wieder auf Daten zu horchen.

Befinden sich hingegen entweder die globale Variable \textit{robot\_shutdown} oder \textit{robot\_failure} im Status \textit{true}, so wird die Zeichenkette "'shutdown"' in konvertiert und dem Sendebuffer übergeben. Damit wird dem Computer mitgeteilt dass der Roboter derzeit nicht verwendbar ist und entweder heruntergefahren wurde oder ein Fehler aufgetreten ist. In beiden Fällen muss eine neue Verbindung mit der Steuerung hergestellt werden und somit der "'Homing Prozess"' durchgeführt werden. Nach dem Senden dieser Mitteilung wird die Verbindung beendet und die \textit{state} Variable wird auf 0 gesetzt um das \textit{NetworkManager} Programm neu zu initialisieren. 

Um die Verbindung zu beenden muss Aufgrund eines Fehler in der OSCAT Library zuerst der Socket manuell geschlossen werden, dies passiert am Beispiel der Steuerungssoftware mit folgender Zeile:

SysSockClose(diSocket:=IP\_CONTROL1.socket);

Wurde dieser Schritt ausgeführt kann über das C\_ENABLED Attribut des übergebenen IP\_C Objekts das IP\_CONTROL abgeschaltet werden.


